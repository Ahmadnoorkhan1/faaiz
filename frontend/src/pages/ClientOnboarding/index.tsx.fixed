import React, { useState, useEffect, useCallback } from "react";
import { useNavigate } from "react-router-dom";
import { useForm, FormProvider, SubmitHandler } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { toast } from "react-hot-toast";
import CardLayout from "../../layouts/CardLayout";
import Stepper from "../../components/Stepper";
import api from "../../service/apiService";
import { ClientFormData, clientSchema } from "../../utils/schemas/clientSchema";
import axios from "axios";

// Import step components
import AccountInfo from "./components/AccountInfo";
import BasicInfo from "./components/BasicInfo";
import PersonalInfo from "./components/PersonalInfo";
import DiscoveryMethod from "./components/DiscoveryMethod";
import ProposalGeneration from "./components/ProposalGeneration";
import InterviewSchedule from "./components/InterviewSchedule";
import LegalTerms from "./components/LegalTerms";

const steps = [
  { title: "Account", description: "Create Account" },
  { title: "Service Selection", description: "Services" },
  { title: "Personal Info", description: "Your Details" },
  { title: "Discovery", description: "Call or Form" },
  { title: 'Proposal', description: 'Generating...' },
  // { title: 'Interview', description: 'Schedule (Optional)' },
  { title: "Legal", description: "Final Steps" },
];

// Fields to watch per step to prevent unnecessary validations
const stepFields = {
  0: ["email", "password", "name"],
  1: ["requestedServices", "otherDetails"],
  2: ["fullName", "phoneNumber", "organization"],
  3: ["discoveryMethod"],
  // 4: [],
  // 5: [],
  6: ["termsAccepted"],
};

// Helper to format service name for readability
const formatServiceName = (service: string): string => {
  return service
    .replace(/_/g, ' ')
    .split(' ')
    .map(word => word.charAt(0) + word.slice(1).toLowerCase())
    .join(' ');
};

const ClientOnboarding: React.FC = () => {
  const navigate = useNavigate();
  const [currentStep, setCurrentStep] = useState(0);
  const [isGeneratingProposal, setIsGeneratingProposal] = useState(false);
  const [isValidating, setIsValidating] = useState(false);
  const [loading, setLoading] = useState(false);
  const [processingStatus, setProcessingStatus] = useState<string>("Creating account...");
  const [stepValidated, setStepValidated] = useState<Record<number, boolean>>({});

  // Change form mode to onSubmit - only validate when explicitly triggered
  const methods = useForm<ClientFormData>({
    resolver: zodResolver(clientSchema),
    mode: "onSubmit",
    defaultValues: {
      email: "",
      password: "",
      name: "",
      requestedServices: [],
      otherDetails: "",
      fullName: "",
      phoneNumber: "",
      organization: "",
      additionalContact: "",
      discoveryMethod: "call",
      scopingDetails: {},
      interviewDate: "",
      interviewTime: "",
      termsAccepted: false,
    },
  });

  const {
    handleSubmit,
    watch,
    trigger,
    getValues,
    formState: { errors, isDirty },
  } = methods;

  // Watch all fields for the current step
  const currentStepFields =
    stepFields[currentStep as keyof typeof stepFields] || [];
  const watchedStepFields = watch(currentStepFields as any);

  // Specifically watch requestedServices for Step 1
  const watchedServices = watch("requestedServices");

  // Improved validation function
  const validateCurrentStep = useCallback(
    async (showToast = true): Promise<boolean> => {
      if (isValidating) return false;

      setIsValidating(true);
      let isValid = false;

      try {
        const fieldsToValidate = [
          ...(stepFields[currentStep as keyof typeof stepFields] || []),
        ];

        // Special case for Step 1 - check if any services are selected
        if (currentStep === 1) {
          const services = getValues("requestedServices");

          if (services.length === 0) {
            if (showToast) {
              toast.error("Please select at least one service");
            }
            setIsValidating(false);
            setStepValidated((prev) => ({ ...prev, [currentStep]: false }));
            return false;
          }

          // If OTHER is selected, validate otherDetails
          if (
            services.includes("OTHER") &&
            !fieldsToValidate.includes("otherDetails")
          ) {
            fieldsToValidate.push("otherDetails");
          }
        }

        // Skip validation for proposal generation and optional steps
        if (currentStep === 4 || currentStep === 5) {
          isValid = true;
        } else if (fieldsToValidate.length > 0) {
          // Trigger validation for all fields in this step
          isValid = await trigger(fieldsToValidate as any, {
            shouldFocus: true,
          });
        } else {
          isValid = true;
        }

        // Set step validation state
        setStepValidated((prev) => ({ ...prev, [currentStep]: isValid }));

        if (!isValid && showToast) {
          toast.error("Please fix the errors before proceeding.");
        }

        return isValid;
      } catch (error) {
        console.error("Validation error:", error);
        if (showToast) {
          toast.error("An error occurred during validation.");
        }
        return false;
      } finally {
        setIsValidating(false);
      }
    },
    [currentStep, getValues, trigger, isValidating]
  );

  // Helper function to download a file from a URL
  const downloadFile = async (url: string): Promise<File | null> => {
    try {
      // Get the file name from URL
      const fileName = url.split('/').pop() || 'template.xlsx';
      
      // Fetch the file
      const response = await axios.get(url, { responseType: 'blob' });
      
      // Create a File object
      const file = new File([response.data], fileName, {
        type: response.headers['content-type'] || 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
      });
      
      return file;
    } catch (error) {
      console.error('Error downloading file:', error);
      return null;
    }
  };

  const onSubmit: SubmitHandler<ClientFormData> = async (data) => {
    try {
      setLoading(true);
      setProcessingStatus("Creating account...");

      // Step 1: Create new client profile
      const clientResponse = await api.post("/api/clients", {
        // User fields
        email: data.email,
        password: data.password,
        
        // ClientProfile fields
        fullName: data.name,
        phoneNumber: data.phoneNumber,
        organization: data.organization,
        additionalContact: data.additionalContact || null,
        
        // Make sure requestedServices is properly formatted as ServiceType[] enum
        requestedServices: data.requestedServices,
        otherDetails: data.otherDetails || null,
        
        // Discovery
        discoveryMethod: data.discoveryMethod || null,
        scopingDetails: data.scopingDetails || {},
        
        // Interview
        interviewDate: data.interviewDate || null,
        interviewTime: data.interviewTime || null,
        
        // Legal
        termsAccepted: data.termsAccepted,
        
        // Status fields
        currentStep: 0,
        onboardingStatus: "COMPLETED", // Set as completed since we're handling everything
      });

      // Extract client data from response - FIXED: Correctly access the clientProfile.id
      const responseData = clientResponse.data.data;
      const clientId = responseData.clientProfile.id;
      const userId = responseData.user.id;
      
      console.log("Created client with ID:", clientId);
      setProcessingStatus("Account created successfully! Preparing project setup...");
      
      // Add 3 second delay before project creation
      await new Promise(resolve => setTimeout(resolve, 3000));
      
      // Get the selected service
      const selectedService = data.requestedServices[0]; // First service in the array

      // Step 2: Create a project for the client
      setProcessingStatus("Creating project...");
      
      const projectPayload = {
        name: `${data.organization} - ${formatServiceName(selectedService)}`,
        description: `${formatServiceName(selectedService)} implementation for ${data.organization}`,
        status: "ACTIVE",
        clientId: clientId, // Using the correct clientId from clientProfile
        userId: userId, // Using the correct userId from clientProfile
        // Let consultantId be assigned by admin later
        startDate: new Date().toISOString().split('T')[0], // Today
        endDate: new Date(new Date().setMonth(new Date().getMonth() + 6)).toISOString().split('T')[0], // 6 months from now
      };
      
      console.log("Creating project with payload:", projectPayload);
      const projectResponse = await api.post('/api/projects', projectPayload);
      
      // Extract project ID from response, ensuring we handle different response formats
      let projectId;
      if (projectResponse && projectResponse.data) {
        // Check common response patterns
        if (projectResponse.data.id) {
          projectId = projectResponse.data.id;
        } else if (projectResponse.data.data && projectResponse.data.data.id) {
          projectId = projectResponse.data.data.id;
        } else if (projectResponse.data.project && projectResponse.data.project.id) {
          projectId = projectResponse.data.project.id;
        }
      }
      
      if (!projectId) {
        console.error("Failed to extract project ID from response:", projectResponse);
        setProcessingStatus("Project created, but couldn't extract project ID for task import.");
      } else {
        console.log("Created project with ID:", projectId);
        setProcessingStatus("Project created successfully! Searching for document templates...");
      
        // Add 3 second delay before fetching document templates
        await new Promise(resolve => setTimeout(resolve, 3000));

        // Step 3: Get document templates for the selected service
        setProcessingStatus("Finding suitable templates for your project...");

        try {
          const documentsResponse = await api.get(`/api/documents/by-service/${selectedService}`);
          const documents = documentsResponse.data;
          
          console.log("Found documents for service:", documents.length);
          
          // Find any Excel spreadsheet document for this service type
          const templateDoc = documents.find((doc: any) => 
            (doc.fileType && (
              doc.fileType.includes("spreadsheet") || 
              doc.fileType.includes("xlsx")
            )) ||
            (doc.title && (
              doc.title.toLowerCase().includes("plan") ||
              doc.title.toLowerCase().includes("format")
            ))
          );
          
          // Step 4: If we found a suitable document, download and import it
          if (templateDoc && templateDoc.fileUrl) {
            setProcessingStatus(`Template found: "${templateDoc.title}". Preparing to import tasks...`);
            console.log("Using template document:", templateDoc.title);
            
            // Add 3 second delay before importing tasks
            await new Promise(resolve => setTimeout(resolve, 3000));
            
            // Download the template file
            const templateFile = await downloadFile(templateDoc.fileUrl);
            
            if (templateFile) {
              setProcessingStatus("Importing tasks from template...");
              
              // Create FormData for file upload
              const formData = new FormData();
              formData.append('file', templateFile);
              
              // Make sure projectId is properly formatted and not null/undefined
              if (projectId) {
                // Convert to string if it's not already (FormData values must be strings or Blobs)
                formData.append('projectId', String(projectId));
                
                console.log("Importing tasks from template for project:", projectId);
                
                // Import tasks from the template
                await api.post('/api/tasks/import', formData, {
                  headers: {
                    'Content-Type': 'multipart/form-data'
                  }
                });
                
                setProcessingStatus("Tasks imported successfully! Your project is ready.");
              } else {
                console.error("Project ID is missing, cannot import tasks");
                setProcessingStatus("Project created, but couldn't import tasks due to missing project ID.");
              }
            } else {
              console.error("Failed to download template file");
              setProcessingStatus("Could not download template file. Project created without tasks.");
            }
          } else {
            console.log("No suitable template document found");
            setProcessingStatus("No task template found. Project created without predefined tasks.");
          }
        } catch (docError) {
          console.error("Error setting up project documents:", docError);
          setProcessingStatus("Project created, but couldn't set up document templates.");
          // Continue with account creation even if document setup fails
        }
      }

      // Final success message and slight delay before success toast
      await new Promise(resolve => setTimeout(resolve, 1500));
      toast.success("Account created and project setup completed successfully!");

      // Redirect to login page
      setTimeout(() => {
        navigate("/login");
      }, 2000);
    } catch (error: unknown) {
      console.error("Error in onboarding process:", error);

      // Handle error based on its type
      let errorMessage = "Failed to complete onboarding.";

      if (error && typeof error === "object") {
        const err = error as Record<string, any>;
        if (err.response?.data?.message) {
          errorMessage += ` ${err.response.data.message}`;
        } else if (err.response?.data?.error) {
          errorMessage += ` ${err.response.data.error}`;
        } else if ("message" in err) {
          errorMessage += ` ${err.message}`;
        }
      }

      toast.error(errorMessage);
    } finally {
      setLoading(false);
    }
  };

  // Handle next button click
  const handleNext = useCallback(async () => {
    if (isValidating || isGeneratingProposal) return;

    const isStepValid = await validateCurrentStep(true);

    if (isStepValid) {
      if (currentStep === 3) {
        setIsGeneratingProposal(true);
        // Simulate proposal generation
        setTimeout(() => {
          setIsGeneratingProposal(false);
          setCurrentStep((prev) => prev + 1);
          // Mark step as validated
          setStepValidated((prev) => ({ ...prev, [currentStep + 1]: true }));
        }, 2000);
      } else {
        setCurrentStep((prev) => prev + 1);
      }
    }
  }, [currentStep, isValidating, isGeneratingProposal, validateCurrentStep]);

  const handleBack = useCallback(() => {
    if (currentStep > 0 && !loading) {
      setCurrentStep((prev) => prev - 1);
    }
  }, [currentStep, loading]);

  const renderStepComponent = useCallback(() => {
    switch (currentStep) {
      case 0:
        return <AccountInfo />;
      case 1:
        return <BasicInfo />;
      case 2:
        return <PersonalInfo />;
      case 3:
        return <DiscoveryMethod />;
      case 4:
        return <ProposalGeneration />;
      // case 5:
      //   return <InterviewSchedule />;
      case 5:
        return <LegalTerms />;
      default:
        return null;
    }
  }, [currentStep]);

  if (loading) {
    return (
      <div className="min-h-screen bg-[#001538] py-8">
        <div className="relative z-10 px-4 sm:px-6 md:px-8 max-w-6xl mx-auto">
          <CardLayout title="Processing Your Request">
            <div className="flex flex-col justify-center items-center py-12">
              <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-[#0078D4] mb-4"></div>
              <p className="text-white text-center mb-2">
                Please wait while we process your information...
              </p>
              <p className="text-white/70 text-center text-sm">
                {processingStatus}
              </p>
            </div>
          </CardLayout>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-[#001538] py-8">
      <div className="relative z-10 px-4 sm:px-6 md:px-8 max-w-6xl mx-auto">
        <CardLayout title="Client Onboarding">
          <FormProvider {...methods}>
            <form onSubmit={handleSubmit(onSubmit)} className="space-y-8">
              <Stepper steps={steps} currentStep={currentStep} />

              <div className="mt-8 w-full min-h-[300px]">
                {renderStepComponent()}
              </div>

              <div className="flex justify-between">
                <button
                  type="button"
                  onClick={handleBack}
                  disabled={
                    currentStep === 0 || loading || isGeneratingProposal
                  }
                  className={`px-4 py-2 border rounded-md text-sm font-medium transition-colors
    ${
      currentStep === 0 || loading || isGeneratingProposal
        ? "text-gray-300 border-gray-300 cursor-not-allowed"
        : "text-gray-700 border-gray-300 bg-white hover:bg-gray-50"
    }`}
                >
                  Back
                </button>
                {currentStep === steps.length - 1 ? (
                  <button
                    type="submit"
                    // disabled={}
                    className={`px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white transition-colors
                      ${
                        loading || isValidating || !stepValidated[currentStep]
                          ? "bg-[#003175] cursor-not-allowed"
                          : "bg-[#0078D4] hover:bg-[#106EBE]"
                      }`}
                  >
                    {loading ? "Submitting..." : "Create Account"}
                  </button>
                ) : (
                  <button
                    type="button"
                    onClick={handleNext}
                    disabled={isGeneratingProposal || loading || isValidating}
                    className={`px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white transition-colors
                      ${
                        isGeneratingProposal || loading || isValidating
                          ? "bg-[#003175] cursor-not-allowed"
                          : "bg-[#0078D4] hover:bg-[#106EBE]"
                      }`}
                  >
                    {isValidating
                      ? "Validating..."
                      : isGeneratingProposal
                      ? "Generating..."
                      : "Next"}
                  </button>
                )}
              </div>
            </form>
          </FormProvider>
        </CardLayout>
      </div>
    </div>
  );
};

export default ClientOnboarding;
